-----------------------------------------------------------------------
--  Search.Models -- Search.Models
-----------------------------------------------------------------------
--  File generated by Dynamo DO NOT MODIFY
--  Template used: templates/model/package-spec.xhtml
--  Ada Generator: https://github.com/stcarrez/dynamo Version 1.4.0
-----------------------------------------------------------------------
--  Copyright (C) 2022 Stephane Carrez
--  Written by Stephane Carrez (Stephane.Carrez@gmail.com)
--
--  Licensed under the Apache License, Version 2.0 (the "License");
--  you may not use this file except in compliance with the License.
--  You may obtain a copy of the License at
--
--      http://www.apache.org/licenses/LICENSE-2.0
--
--  Unless required by applicable law or agreed to in writing, software
--  distributed under the License is distributed on an "AS IS" BASIS,
--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
--  See the License for the specific language governing permissions and
--  limitations under the License.
-----------------------------------------------------------------------
pragma Warnings (Off);
with ADO.Sessions;
with ADO.Objects;
with ADO.Statements;
with ADO.SQL;
with ADO.Schemas;
with Ada.Containers.Vectors;
with Ada.Strings.Unbounded;
with Util.Beans.Objects;
with Util.Beans.Basic.Lists;
pragma Warnings (On);
package Search.Models is

   pragma Style_Checks ("-mrIu");

   type Index_Ref is new ADO.Objects.Object_Ref with null record;

   type Document_Ref is new ADO.Objects.Object_Ref with null record;

   type Field_Ref is new ADO.Objects.Object_Ref with null record;

   type Sequence_Ref is new ADO.Objects.Object_Ref with null record;

   type Token_Ref is new ADO.Objects.Object_Ref with null record;

   --  Create an object key for Index.
   function Index_Key (Id : in ADO.Identifier) return ADO.Objects.Object_Key;
   --  Create an object key for Index from a string.
   --  Raises Constraint_Error if the string cannot be converted into the object key.
   function Index_Key (Id : in String) return ADO.Objects.Object_Key;

   Null_Index : constant Index_Ref;
   function "=" (Left, Right : Index_Ref'Class) return Boolean;

   --  Set the index identifier.
   procedure Set_Id (Object : in out Index_Ref;
                     Value  : in ADO.Identifier);

   --  Get the index identifier.
   function Get_Id (Object : in Index_Ref)
                 return ADO.Identifier;

   --  Load the entity identified by 'Id'.
   --  Raises the NOT_FOUND exception if it does not exist.
   procedure Load (Object  : in out Index_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier);

   --  Load the entity identified by 'Id'.
   --  Returns True in <b>Found</b> if the object was found and False if it does not exist.
   procedure Load (Object  : in out Index_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier;
                   Found   : out Boolean);

   --  Find and load the entity.
   overriding
   procedure Find (Object  : in out Index_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   --  Save the entity.  If the entity does not have an identifier, an identifier is allocated
   --  and it is inserted in the table.  Otherwise, only data fields which have been changed
   --  are updated.
   overriding
   procedure Save (Object  : in out Index_Ref;
                   Session : in out ADO.Sessions.Master_Session'Class);

   --  Delete the entity.
   overriding
   procedure Delete (Object  : in out Index_Ref;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   function Get_Value (From : in Index_Ref;
                       Name : in String) return Util.Beans.Objects.Object;

   --  Table definition
   INDEX_TABLE : constant ADO.Schemas.Class_Mapping_Access;

   --  Internal method to allocate the Object_Record instance
   overriding
   procedure Allocate (Object : in out Index_Ref);

   --  Copy of the object.
   procedure Copy (Object : in Index_Ref;
                   Into   : in out Index_Ref);

   --  Create an object key for Document.
   function Document_Key (Id : in ADO.Identifier) return ADO.Objects.Object_Key;
   --  Create an object key for Document from a string.
   --  Raises Constraint_Error if the string cannot be converted into the object key.
   function Document_Key (Id : in String) return ADO.Objects.Object_Key;

   Null_Document : constant Document_Ref;
   function "=" (Left, Right : Document_Ref'Class) return Boolean;

   --  Set the document identifier.
   procedure Set_Id (Object : in out Document_Ref;
                     Value  : in ADO.Identifier);

   --  Get the document identifier.
   function Get_Id (Object : in Document_Ref)
                 return ADO.Identifier;

   --
   procedure Set_Index (Object : in out Document_Ref;
                        Value  : in Index_Ref'Class);

   --
   function Get_Index (Object : in Document_Ref)
                 return Index_Ref'Class;

   --  Load the entity identified by 'Id'.
   --  Raises the NOT_FOUND exception if it does not exist.
   procedure Load (Object  : in out Document_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier);

   --  Load the entity identified by 'Id'.
   --  Returns True in <b>Found</b> if the object was found and False if it does not exist.
   procedure Load (Object  : in out Document_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier;
                   Found   : out Boolean);

   --  Find and load the entity.
   overriding
   procedure Find (Object  : in out Document_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   --  Save the entity.  If the entity does not have an identifier, an identifier is allocated
   --  and it is inserted in the table.  Otherwise, only data fields which have been changed
   --  are updated.
   overriding
   procedure Save (Object  : in out Document_Ref;
                   Session : in out ADO.Sessions.Master_Session'Class);

   --  Delete the entity.
   overriding
   procedure Delete (Object  : in out Document_Ref;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   function Get_Value (From : in Document_Ref;
                       Name : in String) return Util.Beans.Objects.Object;

   --  Table definition
   DOCUMENT_TABLE : constant ADO.Schemas.Class_Mapping_Access;

   --  Internal method to allocate the Object_Record instance
   overriding
   procedure Allocate (Object : in out Document_Ref);

   --  Copy of the object.
   procedure Copy (Object : in Document_Ref;
                   Into   : in out Document_Ref);

   --  Create an object key for Field.
   function Field_Key (Id : in ADO.Identifier) return ADO.Objects.Object_Key;
   --  Create an object key for Field from a string.
   --  Raises Constraint_Error if the string cannot be converted into the object key.
   function Field_Key (Id : in String) return ADO.Objects.Object_Key;

   Null_Field : constant Field_Ref;
   function "=" (Left, Right : Field_Ref'Class) return Boolean;

   --  Set the field identifier.
   procedure Set_Id (Object : in out Field_Ref;
                     Value  : in ADO.Identifier);

   --  Get the field identifier.
   function Get_Id (Object : in Field_Ref)
                 return ADO.Identifier;

   --  Set the field name.
   procedure Set_Name (Object : in out Field_Ref;
                       Value  : in Ada.Strings.Unbounded.Unbounded_String);
   procedure Set_Name (Object : in out Field_Ref;
                       Value : in String);

   --  Get the field name.
   function Get_Name (Object : in Field_Ref)
                 return Ada.Strings.Unbounded.Unbounded_String;
   function Get_Name (Object : in Field_Ref)
                 return String;

   --  Set the field optional saved value.
   procedure Set_Value (Object : in out Field_Ref;
                        Value  : in Ada.Strings.Unbounded.Unbounded_String);
   procedure Set_Value (Object : in out Field_Ref;
                        Value : in String);

   --  Get the field optional saved value.
   function Get_Value (Object : in Field_Ref)
                 return Ada.Strings.Unbounded.Unbounded_String;
   function Get_Value (Object : in Field_Ref)
                 return String;

   --  Set the field document.
   procedure Set_Document (Object : in out Field_Ref;
                           Value  : in Document_Ref'Class);

   --  Get the field document.
   function Get_Document (Object : in Field_Ref)
                 return Document_Ref'Class;

   --  Load the entity identified by 'Id'.
   --  Raises the NOT_FOUND exception if it does not exist.
   procedure Load (Object  : in out Field_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier);

   --  Load the entity identified by 'Id'.
   --  Returns True in <b>Found</b> if the object was found and False if it does not exist.
   procedure Load (Object  : in out Field_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier;
                   Found   : out Boolean);

   --  Find and load the entity.
   overriding
   procedure Find (Object  : in out Field_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   --  Save the entity.  If the entity does not have an identifier, an identifier is allocated
   --  and it is inserted in the table.  Otherwise, only data fields which have been changed
   --  are updated.
   overriding
   procedure Save (Object  : in out Field_Ref;
                   Session : in out ADO.Sessions.Master_Session'Class);

   --  Delete the entity.
   overriding
   procedure Delete (Object  : in out Field_Ref;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   function Get_Value (From : in Field_Ref;
                       Name : in String) return Util.Beans.Objects.Object;

   --  Table definition
   FIELD_TABLE : constant ADO.Schemas.Class_Mapping_Access;

   --  Internal method to allocate the Object_Record instance
   overriding
   procedure Allocate (Object : in out Field_Ref);

   --  Copy of the object.
   procedure Copy (Object : in Field_Ref;
                   Into   : in out Field_Ref);

   --  Create an object key for Sequence.
   function Sequence_Key (Id : in ADO.Identifier) return ADO.Objects.Object_Key;
   --  Create an object key for Sequence from a string.
   --  Raises Constraint_Error if the string cannot be converted into the object key.
   function Sequence_Key (Id : in String) return ADO.Objects.Object_Key;

   Null_Sequence : constant Sequence_Ref;
   function "=" (Left, Right : Sequence_Ref'Class) return Boolean;

   --
   procedure Set_Positions (Object : in out Sequence_Ref;
                            Value  : in ADO.Blob_Ref);

   --
   function Get_Positions (Object : in Sequence_Ref)
                 return ADO.Blob_Ref;

   --  Set the token being referenced.
   procedure Set_Token (Object : in out Sequence_Ref;
                        Value  : in ADO.Identifier);

   --  Get the token being referenced.
   function Get_Token (Object : in Sequence_Ref)
                 return ADO.Identifier;

   --  Set the field being indexed.
   procedure Set_Field (Object : in out Sequence_Ref;
                        Value  : in ADO.Identifier);

   --  Get the field being indexed.
   function Get_Field (Object : in Sequence_Ref)
                 return ADO.Identifier;

   --  Load the entity identified by 'Id'.
   --  Raises the NOT_FOUND exception if it does not exist.
   procedure Load (Object  : in out Sequence_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier);

   --  Load the entity identified by 'Id'.
   --  Returns True in <b>Found</b> if the object was found and False if it does not exist.
   procedure Load (Object  : in out Sequence_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier;
                   Found   : out Boolean);

   --  Find and load the entity.
   overriding
   procedure Find (Object  : in out Sequence_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   --  Save the entity.  If the entity does not have an identifier, an identifier is allocated
   --  and it is inserted in the table.  Otherwise, only data fields which have been changed
   --  are updated.
   overriding
   procedure Save (Object  : in out Sequence_Ref;
                   Session : in out ADO.Sessions.Master_Session'Class);

   --  Delete the entity.
   overriding
   procedure Delete (Object  : in out Sequence_Ref;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   function Get_Value (From : in Sequence_Ref;
                       Name : in String) return Util.Beans.Objects.Object;

   --  Table definition
   SEQUENCE_TABLE : constant ADO.Schemas.Class_Mapping_Access;

   --  Internal method to allocate the Object_Record instance
   overriding
   procedure Allocate (Object : in out Sequence_Ref);

   --  Copy of the object.
   procedure Copy (Object : in Sequence_Ref;
                   Into   : in out Sequence_Ref);

   --  Create an object key for Token.
   function Token_Key (Id : in ADO.Identifier) return ADO.Objects.Object_Key;
   --  Create an object key for Token from a string.
   --  Raises Constraint_Error if the string cannot be converted into the object key.
   function Token_Key (Id : in String) return ADO.Objects.Object_Key;

   Null_Token : constant Token_Ref;
   function "=" (Left, Right : Token_Ref'Class) return Boolean;

   --  Set the token identifier
   procedure Set_Id (Object : in out Token_Ref;
                     Value  : in ADO.Identifier);

   --  Get the token identifier
   function Get_Id (Object : in Token_Ref)
                 return ADO.Identifier;

   --  Set the token string
   procedure Set_Name (Object : in out Token_Ref;
                       Value  : in Ada.Strings.Unbounded.Unbounded_String);
   procedure Set_Name (Object : in out Token_Ref;
                       Value : in String);

   --  Get the token string
   function Get_Name (Object : in Token_Ref)
                 return Ada.Strings.Unbounded.Unbounded_String;
   function Get_Name (Object : in Token_Ref)
                 return String;

   --
   procedure Set_Index (Object : in out Token_Ref;
                        Value  : in Index_Ref'Class);

   --
   function Get_Index (Object : in Token_Ref)
                 return Index_Ref'Class;

   --  Load the entity identified by 'Id'.
   --  Raises the NOT_FOUND exception if it does not exist.
   procedure Load (Object  : in out Token_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier);

   --  Load the entity identified by 'Id'.
   --  Returns True in <b>Found</b> if the object was found and False if it does not exist.
   procedure Load (Object  : in out Token_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Id      : in ADO.Identifier;
                   Found   : out Boolean);

   --  Find and load the entity.
   overriding
   procedure Find (Object  : in out Token_Ref;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   --  Save the entity.  If the entity does not have an identifier, an identifier is allocated
   --  and it is inserted in the table.  Otherwise, only data fields which have been changed
   --  are updated.
   overriding
   procedure Save (Object  : in out Token_Ref;
                   Session : in out ADO.Sessions.Master_Session'Class);

   --  Delete the entity.
   overriding
   procedure Delete (Object  : in out Token_Ref;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   function Get_Value (From : in Token_Ref;
                       Name : in String) return Util.Beans.Objects.Object;

   --  Table definition
   TOKEN_TABLE : constant ADO.Schemas.Class_Mapping_Access;

   --  Internal method to allocate the Object_Record instance
   overriding
   procedure Allocate (Object : in out Token_Ref);

   --  Copy of the object.
   procedure Copy (Object : in Token_Ref;
                   Into   : in out Token_Ref);




private
   INDEX_NAME : aliased constant String := "search_index";
   COL_0_1_NAME : aliased constant String := "id";

   INDEX_DEF : aliased constant ADO.Schemas.Class_Mapping :=
     (Count   => 1,
      Table   => INDEX_NAME'Access,
      Members => (
         1 => COL_0_1_NAME'Access)
     );
   INDEX_TABLE : constant ADO.Schemas.Class_Mapping_Access
      := INDEX_DEF'Access;


   Null_Index : constant Index_Ref
      := Index_Ref'(ADO.Objects.Object_Ref with null record);

   type Index_Impl is
      new ADO.Objects.Object_Record (Key_Type => ADO.Objects.KEY_INTEGER,
                                     Of_Class => INDEX_DEF'Access)
   with null record;


   type Index_Access is access all Index_Impl;

   overriding
   procedure Destroy (Object : access Index_Impl);

   overriding
   procedure Find (Object  : in out Index_Impl;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   overriding
   procedure Load (Object  : in out Index_Impl;
                   Session : in out ADO.Sessions.Session'Class);
   procedure Load (Object  : in out Index_Impl;
                   Stmt    : in out ADO.Statements.Query_Statement'Class;
                   Session : in out ADO.Sessions.Session'Class);

   overriding
   procedure Save (Object  : in out Index_Impl;
                   Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Create (Object  : in out Index_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Delete (Object  : in out Index_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   procedure Set_Field (Object : in out Index_Ref'Class;
                        Impl   : out Index_Access);
   DOCUMENT_NAME : aliased constant String := "search_document";
   COL_0_2_NAME : aliased constant String := "id";
   COL_1_2_NAME : aliased constant String := "index_id";

   DOCUMENT_DEF : aliased constant ADO.Schemas.Class_Mapping :=
     (Count   => 2,
      Table   => DOCUMENT_NAME'Access,
      Members => (
         1 => COL_0_2_NAME'Access,
         2 => COL_1_2_NAME'Access)
     );
   DOCUMENT_TABLE : constant ADO.Schemas.Class_Mapping_Access
      := DOCUMENT_DEF'Access;


   Null_Document : constant Document_Ref
      := Document_Ref'(ADO.Objects.Object_Ref with null record);

   type Document_Impl is
      new ADO.Objects.Object_Record (Key_Type => ADO.Objects.KEY_INTEGER,
                                     Of_Class => DOCUMENT_DEF'Access)
   with record
       Index : Index_Ref;
   end record;

   type Document_Access is access all Document_Impl;

   overriding
   procedure Destroy (Object : access Document_Impl);

   overriding
   procedure Find (Object  : in out Document_Impl;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   overriding
   procedure Load (Object  : in out Document_Impl;
                   Session : in out ADO.Sessions.Session'Class);
   procedure Load (Object  : in out Document_Impl;
                   Stmt    : in out ADO.Statements.Query_Statement'Class;
                   Session : in out ADO.Sessions.Session'Class);

   overriding
   procedure Save (Object  : in out Document_Impl;
                   Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Create (Object  : in out Document_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Delete (Object  : in out Document_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   procedure Set_Field (Object : in out Document_Ref'Class;
                        Impl   : out Document_Access);
   FIELD_NAME : aliased constant String := "search_field";
   COL_0_3_NAME : aliased constant String := "id";
   COL_1_3_NAME : aliased constant String := "name";
   COL_2_3_NAME : aliased constant String := "value";
   COL_3_3_NAME : aliased constant String := "document_id";

   FIELD_DEF : aliased constant ADO.Schemas.Class_Mapping :=
     (Count   => 4,
      Table   => FIELD_NAME'Access,
      Members => (
         1 => COL_0_3_NAME'Access,
         2 => COL_1_3_NAME'Access,
         3 => COL_2_3_NAME'Access,
         4 => COL_3_3_NAME'Access)
     );
   FIELD_TABLE : constant ADO.Schemas.Class_Mapping_Access
      := FIELD_DEF'Access;


   Null_Field : constant Field_Ref
      := Field_Ref'(ADO.Objects.Object_Ref with null record);

   type Field_Impl is
      new ADO.Objects.Object_Record (Key_Type => ADO.Objects.KEY_INTEGER,
                                     Of_Class => FIELD_DEF'Access)
   with record
       Name : Ada.Strings.Unbounded.Unbounded_String;
       Value : Ada.Strings.Unbounded.Unbounded_String;
       Document : Document_Ref;
   end record;

   type Field_Access is access all Field_Impl;

   overriding
   procedure Destroy (Object : access Field_Impl);

   overriding
   procedure Find (Object  : in out Field_Impl;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   overriding
   procedure Load (Object  : in out Field_Impl;
                   Session : in out ADO.Sessions.Session'Class);
   procedure Load (Object  : in out Field_Impl;
                   Stmt    : in out ADO.Statements.Query_Statement'Class;
                   Session : in out ADO.Sessions.Session'Class);

   overriding
   procedure Save (Object  : in out Field_Impl;
                   Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Create (Object  : in out Field_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Delete (Object  : in out Field_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   procedure Set_Field (Object : in out Field_Ref'Class;
                        Impl   : out Field_Access);
   SEQUENCE_NAME : aliased constant String := "search_sequence";
   COL_0_4_NAME : aliased constant String := "positions";
   COL_1_4_NAME : aliased constant String := "token";
   COL_2_4_NAME : aliased constant String := "field";

   SEQUENCE_DEF : aliased constant ADO.Schemas.Class_Mapping :=
     (Count   => 3,
      Table   => SEQUENCE_NAME'Access,
      Members => (
         1 => COL_0_4_NAME'Access,
         2 => COL_1_4_NAME'Access,
         3 => COL_2_4_NAME'Access)
     );
   SEQUENCE_TABLE : constant ADO.Schemas.Class_Mapping_Access
      := SEQUENCE_DEF'Access;


   Null_Sequence : constant Sequence_Ref
      := Sequence_Ref'(ADO.Objects.Object_Ref with null record);

   type Sequence_Impl is
      new ADO.Objects.Object_Record (Key_Type => ADO.Objects.KEY_INTEGER,
                                     Of_Class => SEQUENCE_DEF'Access)
   with record
       Positions : ADO.Blob_Ref;
       Token : ADO.Identifier;
   end record;

   type Sequence_Access is access all Sequence_Impl;

   overriding
   procedure Destroy (Object : access Sequence_Impl);

   overriding
   procedure Find (Object  : in out Sequence_Impl;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   overriding
   procedure Load (Object  : in out Sequence_Impl;
                   Session : in out ADO.Sessions.Session'Class);
   procedure Load (Object  : in out Sequence_Impl;
                   Stmt    : in out ADO.Statements.Query_Statement'Class;
                   Session : in out ADO.Sessions.Session'Class);

   overriding
   procedure Save (Object  : in out Sequence_Impl;
                   Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Create (Object  : in out Sequence_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Delete (Object  : in out Sequence_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   procedure Set_Field (Object : in out Sequence_Ref'Class;
                        Impl   : out Sequence_Access);
   TOKEN_NAME : aliased constant String := "search_token";
   COL_0_5_NAME : aliased constant String := "id";
   COL_1_5_NAME : aliased constant String := "name";
   COL_2_5_NAME : aliased constant String := "index_id";

   TOKEN_DEF : aliased constant ADO.Schemas.Class_Mapping :=
     (Count   => 3,
      Table   => TOKEN_NAME'Access,
      Members => (
         1 => COL_0_5_NAME'Access,
         2 => COL_1_5_NAME'Access,
         3 => COL_2_5_NAME'Access)
     );
   TOKEN_TABLE : constant ADO.Schemas.Class_Mapping_Access
      := TOKEN_DEF'Access;


   Null_Token : constant Token_Ref
      := Token_Ref'(ADO.Objects.Object_Ref with null record);

   type Token_Impl is
      new ADO.Objects.Object_Record (Key_Type => ADO.Objects.KEY_INTEGER,
                                     Of_Class => TOKEN_DEF'Access)
   with record
       Name : Ada.Strings.Unbounded.Unbounded_String;
       Index : Index_Ref;
   end record;

   type Token_Access is access all Token_Impl;

   overriding
   procedure Destroy (Object : access Token_Impl);

   overriding
   procedure Find (Object  : in out Token_Impl;
                   Session : in out ADO.Sessions.Session'Class;
                   Query   : in ADO.SQL.Query'Class;
                   Found   : out Boolean);

   overriding
   procedure Load (Object  : in out Token_Impl;
                   Session : in out ADO.Sessions.Session'Class);
   procedure Load (Object  : in out Token_Impl;
                   Stmt    : in out ADO.Statements.Query_Statement'Class;
                   Session : in out ADO.Sessions.Session'Class);

   overriding
   procedure Save (Object  : in out Token_Impl;
                   Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Create (Object  : in out Token_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   overriding
   procedure Delete (Object  : in out Token_Impl;
                     Session : in out ADO.Sessions.Master_Session'Class);

   procedure Set_Field (Object : in out Token_Ref'Class;
                        Impl   : out Token_Access);
end Search.Models;
